from typing import Any, Dict, List, Optional, Tuple
from .traversal_types import (
    Edge,
    QueuedNodeValuesState,
    NodeIdentifier,
    InputValues,
    OutputValues,
    NodeValue,
    NodeValuesQueuesMap,
)

class MachineEdgeState(QueuedNodeValuesState):
    state: NodeValuesQueuesMap = {}
    constants: NodeValuesQueuesMap = {}

    def _queueOutput(
        self, 
        map: NodeValuesQueuesMap,
        node: NodeIdentifier,
        key: str,
        value: NodeValue
    ):
        if node not in map:
            map[node] = {}
        queuesMap = map[node]
        if key not in queuesMap:
            queuesMap[key] = []
        queuesMap[key].append(value)

    def wireOutputs(self, opportunities: List[Edge], outputs: OutputValues) -> None:
        """Processes outputs by wiring them to the destinations according
        to the supplied edges. Assumes that the outputs were generated by
        the from node.

        @param opportunities {Edge[]} Edges to process
        @param outputs {OutputValues} Outputs to wire
        """
        # Verify that all edges are from the same node.
        if any(opportunity for opportunity in opportunities if opportunity.previous != opportunities[0].previous):
            raise Exception("All opportunities must be from the same node")

        for opportunity in opportunities:
            to = opportunity.next
            out = opportunity.out
            queuesMap = self.constants if opportunity.constant else self.state
            if not out:
                return
            if out == "*":
                for key in outputs:
                    if key in outputs:
                        self._queueOutput(queuesMap, to, key, outputs[key])
            elif opportunity.input:
                if out in outputs:
                    self._queueOutput(queuesMap, to, opportunity.input, outputs[out])

    def getAvailableInputs(self, nodeId: NodeIdentifier) -> InputValues:
        """Returns the available inputs for a given node.

        @param nodeId {NodeIdentifier} The node to get the inputs for.
        @returns {InputValues} The available inputs.
        """
        result: InputValues = {}

        for queuesMap in [
            self.constants.get(nodeId), # Constants are overwritten by state.
            self.state.get(nodeId),
        ]:
            if not queuesMap:
                continue
            for key, queue in queuesMap.items():
                if len(queue) == 0:
                    continue
                result[key] = queue[0]
        return result

    def useInputs(self, nodeId: NodeIdentifier, inputs: InputValues) -> None:
        """Shifts inputs from the queues. Leaves constants as is.

        @param nodeId {NodeIdentifier} The node to shift the inputs for.
        @param inputs {InputValues} The inputs that are used.
        """
        queuesMap = self.state.get(nodeId)
        if not queuesMap:
            return
        for key in inputs:
            queue = queuesMap.get(key)
            if not queue:
                continue
            queue.pop(0)
